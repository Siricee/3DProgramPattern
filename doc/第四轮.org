* TODO 修改UML描述

** TODO 增加： 我们介绍下各个模块的依赖关系：xxx

注：抽象UML可以在“角色之间的关系”中增加依赖关系说明


** TODO UML中的函数增加返回值类型？



** TODO 角色之间的关系？ 中增加 x对x 的明确描述

如：
- 因为入口积木依赖多个其它积木，所以Entry Block和Block Protocol是一对多的依赖关系

- 因为BlockManager通过registerBlock函数注册了多个积木，所以BlockManager与System Blocks中的积木是一对多的组合关系


* TODO 修改分析角色

** TODO “总体来看”加上用户这个部分，使其与UML中一致


* TODO 修改代码

** TODO 都改为调用模块.xxx函数

如：
Client
```ts
...

let engineState = createState()

engineState = registerAllPipelines(engineState)

...
```

改为：
Client
```ts
...

let engineState = World.createState()

engineState = World.registerAllPipelines(engineState)

...
```



** TODO state的名字重命名为对应的state名

如管道模式->story_improve->Client：
将state重命名为editorState


** TODO 处理这种 splice_pattern_utils/Client
来自拼接模式


* TODO 给出代码：在“总”中给出进一步的说明每一步的关系

如将下面的描述：
首先，我们看下用户的代码；
然后，我们看下Engine的代码
然后，我们看下创建EngineState的代码
然后，我们看下创建场景的代码
然后，我们看下初始化的代码
然后，我们看下主循环的代码
最后，我们运行代码

改为：
首先，我们看下用户的代码；
然后，因为用户调用了Engine的API，所以我们看下Engine的代码
然后，我们依次看下用户代码中每个步骤的相关代码，它们包括：
- 创建EngineState的代码
- 创建场景的代码
- 初始化的代码
- 主循环的代码

最后，我们运行代码



* TODO 给出代码：“总”中一般会使用模块名

如将：
首先，我们看下用户的代码；

改为：
首先，我们看下Client的代码；



* TODO 每个模式的具体案例增加到4个


* TODO 删除注释文字









* TODO 修改结构，改成正式成书的结构(use markdown)

** TODO 确定标题

** TODO 整理合并段落语句



* TODO 更新代码库，给出索引、how to run

** TODO update README

** TODO give where has code, uml and how to run code and run result for each example

    TODO give how to run rescript code(pipeline pattern should mention it!)



** TODO 整理每个package代码，给出运行代码的script；并在README中说明如何运行，怎样运行


** TODO 对用Rescript写的package，说明如何编译，以及package.json->main对应哪个src/的.res文件



** TODO 代码示例

https://github.com/nivance/DPModel