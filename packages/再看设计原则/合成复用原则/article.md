# 定义

尽量使用组合而不是继承

# 补充说明

“继承”属于面向对象编程，函数式编程中没有“继承”的概念
但是，函数式编程其实也可以实现“继承”，只是把“类”换成“模块”，如Rescript支持在一个模块B中引入另一个模块A，使得B获得了A的所有成员，这相当于B继承了A

相关代码如下：
```res
module A = {
  let value1 = "A1"

  let func1 = () => {
    1
  }
}

module B = {
  //引入A
  include A

  //覆盖了A.value1
  let value1 = "B1"

  let func2 = () => {
    //调用A.func1
    func1()
  }
}
```

所以说合成复用原则也适用于函数式编程

继承的领域模型如下：
TODO tu

我们来看下继承的优缺点：
继承的优点：
- 实现新的子模块比较容易，因为子模块可以直接通过继承获得父模块的成员
- 可以在父模块的基础上扩展子模块

继承的缺点：

- 继承破坏了封装，父模块的细节完全暴露给子模块，父模块的任何细节发生了改变都会影响到子模块
- 继承是静态的，在运行时不能改变继承关系


组合的领域模型如下：
TODO tu

我们来看下组合的优缺点：
组合的优点：
- 组合保持了封装，因为新模块看不到已有模块的细节，新模块只能通过已有模块的接口来访问它
<!-- - 能够通过装饰器模式等方法来包装组合 -->
- 组合是动态的，在运行时能改变组合关系

组合的缺点：
- 模块的数量会比较多



继承关系属于“Is-A”的关系，而组合关系却属于“Has-A”的关系

# 案例1

TODO tu
如上图所示，因为雇员、学生都是人，它们与人是“Is-A”的关系，所以它们的关系是继承关系

实际上，雇员、经理是两种角色，而人可以同时有几种不同的角色
如一个人可以既是雇员又是经理，然而这里使用继承的话，每个人就只能有一种角色，这不是很合理

因此，我们将它们由继承关系改为组合关系，修改后的领域模型如下：
TODO tu

现在，一个人可以通过组合不同的角色，来拥有多个角色

